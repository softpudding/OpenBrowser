<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenBrowserAgent - Terminal Interface</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Monaco', 'Menlo', 'Consolas', 'Courier New', monospace;
            background-color: #0a0a0a;
            color: #00ff00;
            line-height: 1.4;
            min-height: 100vh;
            padding: 0;
            overflow-x: hidden;
        }

        .terminal-header {
            background: #111111;
            border-bottom: 1px solid #333333;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }

        .ascii-title {
            font-family: monospace;
            white-space: pre;
            font-size: 12px;
            line-height: 1.2;
            color: #00ff00;
            margin: 0;
            letter-spacing: 0.5px;
        }

        .status-bar {
            display: flex;
            gap: 15px;
            font-size: 12px;
        }

        .status-item {
            padding: 4px 8px;
            background: #222222;
            border-radius: 3px;
            border: 1px solid #333333;
        }

        .status-connected {
            color: #00ff00;
        }

        .status-disconnected {
            color: #ff3333;
        }

        .container {
            display: flex;
            height: calc(100vh - 60px);
        }

        .main-terminal {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #0a0a0a;
            border-right: 1px solid #333333;
        }

        .terminal-output {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 13px;
            line-height: 1.5;
        }

        .event-line {
            margin-bottom: 8px;
            padding: 5px 10px;
            border-left: 2px solid #333333;
            transition: all 0.2s;
            cursor: pointer;
            position: relative;
        }

        .event-line:hover {
            background: #111111;
            border-left-color: #00ff00;
        }

        .event-line.collapsed {
            max-height: 24px;
            overflow: hidden;
        }

        .event-line.expanded {
            background: #111111;
            border-left-color: #00ff00;
        }

        .event-header {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .event-type {
            font-weight: bold;
            color: #00ccff;
            margin-right: 10px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .event-timestamp {
            color: #666666;
            font-size: 10px;
            margin-right: 10px;
        }

        .expand-toggle {
            color: #666666;
            font-size: 10px;
            margin-left: auto;
            cursor: pointer;
            user-select: none;
        }

        .expand-toggle:hover {
            color: #00ff00;
        }

        .event-content {
            white-space: pre-wrap;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 12px;
            color: #cccccc;
            line-height: 1.4;
        }

        .event-image {
            margin-top: 10px;
            max-width: 100%;
            border: 1px solid #333333;
            border-radius: 3px;
        }

        .prompt-line {
            color: #00ff00;
        }

        .prompt-line::before {
            content: "> ";
            color: #00ff00;
        }

        .input-area {
            border-top: 1px solid #333333;
            padding: 15px 20px;
            background: #111111;
            display: flex;
            align-items: center;
        }

        .input-prompt {
            color: #00ff00;
            margin-right: 10px;
            user-select: none;
        }

        .command-input {
            flex: 1;
            background: transparent;
            border: none;
            color: #00ff00;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 13px;
            outline: none;
            caret-color: #00ff00;
        }

        .command-input::placeholder {
            color: #666666;
        }

        .send-button {
            background: #222222;
            color: #00ff00;
            border: 1px solid #333333;
            padding: 6px 15px;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 12px;
            cursor: pointer;
            margin-left: 10px;
            transition: all 0.2s;
        }

        .send-button:hover:not(:disabled) {
            background: #00ff00;
            color: #000000;
            border-color: #00ff00;
        }

        .send-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .sidebar {
            width: 300px;
            background: #111111;
            padding: 20px;
            border-left: 1px solid #333333;
            overflow-y: auto;
        }

        .sidebar-section {
            margin-bottom: 25px;
        }

        .sidebar-title {
            color: #00ff00;
            font-size: 14px;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #333333;
        }

        .connection-info {
            background: #222222;
            padding: 10px;
            border-radius: 3px;
            border: 1px solid #333333;
            margin-bottom: 15px;
        }

        .info-line {
            margin-bottom: 5px;
            font-size: 11px;
        }

        .info-label {
            color: #666666;
            display: inline-block;
            width: 80px;
        }

        .info-value {
            color: #cccccc;
        }

        .event-stats {
            background: #222222;
            padding: 10px;
            border-radius: 3px;
            border: 1px solid #333333;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 11px;
        }

        .stat-label {
            color: #666666;
        }

        .stat-value {
            color: #cccccc;
        }

        .scrollbar {
            scrollbar-width: thin;
            scrollbar-color: #333333 #111111;
        }

        .scrollbar::-webkit-scrollbar {
            width: 8px;
        }

        .scrollbar::-webkit-scrollbar-track {
            background: #111111;
        }

        .scrollbar::-webkit-scrollbar-thumb {
            background: #333333;
            border-radius: 4px;
        }

        .scrollbar::-webkit-scrollbar-thumb:hover {
            background: #444444;
        }

        .blink {
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        .system-event {
            color: #666666;
        }

        .user-event {
            color: #00ccff;
        }

        .agent-event {
            color: #00ff00;
        }

        .action-event {
            color: #ffcc00;
        }

        .observation-event {
            color: #ff66cc;
        }

        .error-event {
            color: #ff3333;
        }
        
        .hidden {
            display: none !important;
        }
        
        .loading-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #333333;
            border-top-color: #00ff00;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="terminal-header">
        <div class="ascii-title">
  ___                   _    ____              _               _   
 / _ \ _ __   ___ _ __ | |_ | __ )  ___   ___ | | _____ _ __  / \  
| | | | '_ \ / _ \ '_ \| __||  _ \ / _ \ / _ \| |/ / _ \ '__| /  \ 
| |_| | |_) |  __/ | | | |_ | |_) | (_) | (_) |   <  __/ |   / /\ \ 
 \___/| .__/ \___|_| |_|\__||____/ \___/ \___/|_|\_\___|_|  /_/  \_\
      |_|                                                          
        </div>
        <div class="status-bar">
            <div class="status-item" id="server-status">SERVER: <span class="status-disconnected">DISCONNECTED</span></div>
            <div class="status-item" id="browser-status">BROWSER: <span class="status-disconnected">NOT CONNECTED</span></div>
            <div class="status-item" id="event-count">EVENTS: <span>0</span></div>
        </div>
    </div>
    
    <div class="container">
        <div class="main-terminal">
            <div class="terminal-output scrollbar" id="terminal-output">
                <!-- Event lines will be dynamically added here -->
                <div class="event-line expanded">
                    <div class="event-header">
                        <span class="event-type system-event">SYSTEM</span>
                        <span class="event-timestamp" id="current-time"></span>
                        <span class="expand-toggle" onclick="toggleEvent(this)">[collapse]</span>
                    </div>
                    <div class="event-content">
                        <div class="prompt-line">OpenBrowserAgent Terminal Interface v1.0</div>
                        <div class="prompt-line">Type commands below to control the browser via AI</div>
                        <div class="prompt-line">System ready. Waiting for input...</div>
                    </div>
                </div>
            </div>
            
            <div class="input-area">
                <div class="input-prompt blink">></div>
                <input type="text" class="command-input" id="command-input" placeholder="Type a command (e.g., 'open google.com') and press Enter" autofocus>
                <button class="send-button" id="send-button" onclick="sendCommand()">SEND</button>
            </div>
        </div>
        
        <div class="sidebar scrollbar">
            <div class="sidebar-section">
                <div class="sidebar-title">CONNECTION INFO</div>
                <div class="connection-info">
                    <div class="info-line">
                        <span class="info-label">Server:</span>
                        <span class="info-value" id="server-url">http://127.0.0.1:8765</span>
                    </div>
                    <div class="info-line">
                        <span class="info-label">Status:</span>
                        <span class="info-value" id="connection-status">Not connected</span>
                    </div>
                    <div class="info-line">
                        <span class="info-label">Conversation:</span>
                        <span class="info-value" id="conversation-id">None</span>
                    </div>
                </div>
            </div>
            
            <div class="sidebar-section">
                <div class="sidebar-title">EVENT STATISTICS</div>
                <div class="event-stats">
                    <div class="stat-item">
                        <span class="stat-label">Total Events:</span>
                        <span class="stat-value" id="stat-total">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">System Events:</span>
                        <span class="stat-value" id="stat-system">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Message Events:</span>
                        <span class="stat-value" id="stat-message">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Action Events:</span>
                        <span class="stat-value" id="stat-action">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Observation Events:</span>
                        <span class="stat-value" id="stat-observation">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Errors:</span>
                        <span class="stat-value" id="stat-error">0</span>
                    </div>
                </div>
            </div>
            
            <div class="sidebar-section">
                <div class="sidebar-title">FILTER SETTINGS</div>
                <div class="event-stats">
                    <div class="stat-item">
                        <span class="stat-label">Show System Events:</span>
                        <span class="stat-value">
                            <input type="checkbox" id="filter-system" checked onchange="updateEventVisibility()">
                        </span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Show User Messages:</span>
                        <span class="stat-value">
                            <input type="checkbox" id="filter-user-message" checked onchange="updateEventVisibility()">
                        </span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Auto-expand Events:</span>
                        <span class="stat-value">
                            <input type="checkbox" id="auto-expand" checked>
                        </span>
                    </div>
                </div>
            </div>
            
            <div class="sidebar-section">
                <div class="sidebar-title">QUICK COMMANDS</div>
                <div class="event-stats">
                    <div class="stat-item">
                        <button class="send-button" style="width: 100%; margin: 5px 0; font-size: 11px;" onclick="setCommand('open google.com')">open google.com</button>
                    </div>
                    <div class="stat-item">
                        <button class="send-button" style="width: 100%; margin: 5px 0; font-size: 11px;" onclick="setCommand('tabs list')">tabs list</button>
                    </div>
                    <div class="stat-item">
                        <button class="send-button" style="width: 100%; margin: 5px 0; font-size: 11px;" onclick="setCommand('mouse reset')">mouse reset</button>
                    </div>
                    <div class="stat-item">
                        <button class="send-button" style="width: 100%; margin: 5px 0; font-size: 11px;" onclick="clearTerminal()">CLEAR TERMINAL</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Global variables
        let currentConversationId = null;
        let eventSource = null;
        let isProcessing = false;
        let eventCounters = {
            total: 0,
            system: 0,
            message: 0,
            action: 0,
            observation: 0,
            error: 0
        };
        let events = []; // Store all events for filtering
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            updateCurrentTime();
            setInterval(updateCurrentTime, 1000);
            checkServerStatus();
            
            // Set up event listeners
            document.getElementById('command-input').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    sendCommand();
                }
            });
            
            // Load saved conversation ID from localStorage
            const savedConvId = localStorage.getItem('openbrowser_conversation_id');
            if (savedConvId) {
                currentConversationId = savedConvId;
                updateConversationIdDisplay();
            }
        });
        
        // Update current time display
        function updateCurrentTime() {
            const now = new Date();
            const timeStr = now.toLocaleTimeString('en-US', { hour12: false });
            document.getElementById('current-time').textContent = timeStr;
        }
        
        // Check server status
        async function checkServerStatus() {
            try {
                const response = await fetch('/health');
                const data = await response.json();
                
                if (data.status === 'healthy') {
                    document.getElementById('server-status').innerHTML = 'SERVER: <span class="status-connected">CONNECTED</span>';
                    document.getElementById('connection-status').textContent = 'Connected';
                    document.getElementById('connection-status').className = 'info-value status-connected';
                    
                    if (data.websocket_connected) {
                        document.getElementById('browser-status').innerHTML = 'BROWSER: <span class="status-connected">CONNECTED</span>';
                    } else {
                        document.getElementById('browser-status').innerHTML = 'BROWSER: <span class="status-disconnected">NOT CONNECTED</span>';
                    }
                } else {
                    document.getElementById('server-status').innerHTML = 'SERVER: <span class="status-disconnected">ERROR</span>';
                    document.getElementById('connection-status').textContent = 'Error';
                    document.getElementById('connection-status').className = 'info-value status-disconnected';
                }
            } catch (error) {
                document.getElementById('server-status').innerHTML = 'SERVER: <span class="status-disconnected">OFFLINE</span>';
                document.getElementById('connection-status').textContent = 'Offline';
                document.getElementById('connection-status').className = 'info-value status-disconnected';
                document.getElementById('browser-status').innerHTML = 'BROWSER: <span class="status-disconnected">UNKNOWN</span>';
            }
        }
        
        // Send command to agent
        async function sendCommand() {
            const input = document.getElementById('command-input');
            const command = input.value.trim();
            
            if (!command || isProcessing) {
                return;
            }
            
            // Clear input
            input.value = '';
            
            // Add user command to terminal (if filter allows)
            if (document.getElementById('filter-user-message').checked) {
                addEvent({
                    type: 'MessageEvent',
                    text: `User: ${command}`,
                    timestamp: new Date().toISOString(),
                    source: 'user'
                });
            }
            
            // Disable send button
            isProcessing = true;
            document.getElementById('send-button').disabled = true;
            
            // Create or use existing conversation
            let conversationId = currentConversationId;
            if (!conversationId) {
                try {
                    const response = await fetch('/agent/conversations', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    const data = await response.json();
                    conversationId = data.conversation_id;
                    currentConversationId = conversationId;
                    localStorage.setItem('openbrowser_conversation_id', conversationId);
                    updateConversationIdDisplay();
                } catch (error) {
                    addEvent({
                        type: 'ErrorEvent',
                        text: `Failed to create conversation: ${error.message}`,
                        timestamp: new Date().toISOString()
                    });
                    isProcessing = false;
                    document.getElementById('send-button').disabled = false;
                    return;
                }
            }
            
            // Close existing EventSource if any
            if (eventSource) {
                eventSource.close();
            }
            
            // Setup SSE connection
            setupEventSource(conversationId, command);
        }
        
        // Setup SSE connection for receiving events
        function setupEventSource(conversationId, command) {
            const url = `/agent/conversations/${conversationId}/messages`;
            
            eventSource = new EventSource(url, {
                withCredentials: false
            });
            
            // Send the command
            fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ text: command })
            }).catch(error => {
                addEvent({
                    type: 'ErrorEvent',
                    text: `Failed to send command: ${error.message}`,
                    timestamp: new Date().toISOString()
                });
                isProcessing = false;
                document.getElementById('send-button').disabled = false;
                eventSource.close();
            });
            
            // Handle incoming events
            eventSource.addEventListener('agent_event', function(event) {
                try {
                    const data = JSON.parse(event.data);
                    processEvent(data);
                } catch (error) {
                    console.error('Error parsing agent_event:', error);
                }
            });
            
            eventSource.addEventListener('complete', function(event) {
                try {
                    const data = JSON.parse(event.data);
                    addEvent({
                        type: 'SystemEvent',
                        text: `Conversation completed: ${data.message || 'Done'}`,
                        timestamp: new Date().toISOString()
                    });
                    
                    // Re-enable send button
                    isProcessing = false;
                    document.getElementById('send-button').disabled = false;
                    
                    // Close EventSource
                    if (eventSource) {
                        eventSource.close();
                        eventSource = null;
                    }
                } catch (error) {
                    console.error('Error parsing complete event:', error);
                }
            });
            
            eventSource.addEventListener('error', function(event) {
                try {
                    const data = JSON.parse(event.data);
                    addEvent({
                        type: 'ErrorEvent',
                        text: `Error: ${data.error || data.message || 'Unknown error'}`,
                        timestamp: new Date().toISOString()
                    });
                    
                    // Re-enable send button
                    isProcessing = false;
                    document.getElementById('send-button').disabled = false;
                    
                    // Close EventSource
                    if (eventSource) {
                        eventSource.close();
                        eventSource = null;
                    }
                } catch (error) {
                    console.error('Error parsing error event:', error);
                    addEvent({
                        type: 'ErrorEvent',
                        text: `SSE Error: ${event.type}`,
                        timestamp: new Date().toISOString()
                    });
                }
            });
            
            // Handle connection errors
            eventSource.onerror = function(error) {
                console.error('EventSource error:', error);
                // Don't add error event here to avoid duplicates with 'error' event
                
                // Re-enable send button
                isProcessing = false;
                document.getElementById('send-button').disabled = false;
                
                // Close EventSource
                if (eventSource) {
                    eventSource.close();
                    eventSource = null;
                }
            };
        }
        
        // Process incoming event
        function processEvent(data) {
            // Apply filtering rules
            const eventType = data.type;
            
            // Skip SystemPromptEvent entirely (not shown at all)
            if (eventType === 'SystemPromptEvent') {
                return;
            }
            
            // Skip MessageEvent from user (we already show user input separately)
            if (eventType === 'MessageEvent' && data.text && data.text.includes('user:')) {
                return;
            }
            
            // Create event object
            const event = {
                id: `event-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                type: eventType,
                text: data.text || '',
                timestamp: data.timestamp || new Date().toISOString(),
                image: data.image || null,
                success: data.success,
                message: data.message,
                error: data.error,
                source: data.text && data.text.includes('user:') ? 'user' : 'agent'
            };
            
            // Add to events array
            events.push(event);
            
            // Update counters
            updateEventCounters(eventType);
            
            // Render event
            addEvent(event);
        }
        
        // Update event counters and display
        function updateEventCounters(eventType) {
            eventCounters.total++;
            
            switch (eventType) {
                case 'SystemPromptEvent':
                    eventCounters.system++;
                    break;
                case 'MessageEvent':
                    eventCounters.message++;
                    break;
                case 'ActionEvent':
                    eventCounters.action++;
                    break;
                case 'ObservationEvent':
                    eventCounters.observation++;
                    break;
                case 'ErrorEvent':
                    eventCounters.error++;
                    break;
            }
            
            // Update display
            document.getElementById('event-count').innerHTML = `EVENTS: <span>${eventCounters.total}</span>`;
            document.getElementById('stat-total').textContent = eventCounters.total;
            document.getElementById('stat-system').textContent = eventCounters.system;
            document.getElementById('stat-message').textContent = eventCounters.message;
            document.getElementById('stat-action').textContent = eventCounters.action;
            document.getElementById('stat-observation').textContent = eventCounters.observation;
            document.getElementById('stat-error').textContent = eventCounters.error;
        }
        
        // Add event to terminal display
        function addEvent(event) {
            const terminalOutput = document.getElementById('terminal-output');
            
            // Create event line
            const eventLine = document.createElement('div');
            eventLine.className = 'event-line collapsed';
            eventLine.id = event.id;
            eventLine.dataset.type = event.type;
            eventLine.dataset.source = event.source || 'system';
            
            // Determine event type class
            let typeClass = 'system-event';
            if (event.type === 'MessageEvent') {
                typeClass = event.source === 'user' ? 'user-event' : 'agent-event';
            } else if (event.type === 'ActionEvent') {
                typeClass = 'action-event';
            } else if (event.type === 'ObservationEvent') {
                typeClass = 'observation-event';
            } else if (event.type === 'ErrorEvent') {
                typeClass = 'error-event';
            }
            
            // Format timestamp
            const timestamp = new Date(event.timestamp);
            const timeStr = timestamp.toLocaleTimeString('en-US', { hour12: false });
            
            // Build content
            let content = event.text || event.message || '';
            if (event.error) {
                content = `ERROR: ${event.error}`;
            }
            
            // Create HTML
            eventLine.innerHTML = `
                <div class="event-header">
                    <span class="event-type ${typeClass}">${event.type.replace('Event', '').toUpperCase()}</span>
                    <span class="event-timestamp">${timeStr}</span>
                    <span class="expand-toggle" onclick="toggleEvent(this)">[expand]</span>
                </div>
                <div class="event-content">
                    ${formatContent(content)}
                    ${event.image ? `<img class="event-image" src="${event.image}" alt="Screenshot" onload="this.parentElement.parentElement.classList.add('has-image')">` : ''}
                </div>
            `;
            
            // Apply filter visibility
            updateEventVisibility(eventLine);
            
            // Add to terminal
            terminalOutput.appendChild(eventLine);
            
            // Auto-expand if setting is enabled
            const autoExpand = document.getElementById('auto-expand').checked;
            if (autoExpand) {
                expandEvent(eventLine);
            }
            
            // Scroll to bottom
            terminalOutput.scrollTop = terminalOutput.scrollHeight;
            
            return eventLine;
        }
        
        // Format content for display
        function formatContent(content) {
            if (!content) return '';
            
            // Convert line breaks
            content = content.replace(/\n/g, '<br>');
            
            // Add prompt style to lines that start with certain patterns
            content = content.replace(/^(\s*)(>|\$|#)/gm, '$1<span class="prompt-line">$2</span>');
            
            return content;
        }
        
        // Toggle event expansion
        function toggleEvent(toggleElement) {
            const eventLine = toggleElement.closest('.event-line');
            if (eventLine.classList.contains('collapsed')) {
                expandEvent(eventLine);
            } else {
                collapseEvent(eventLine);
            }
        }
        
        // Expand event
        function expandEvent(eventLine) {
            eventLine.classList.remove('collapsed');
            eventLine.classList.add('expanded');
            const toggle = eventLine.querySelector('.expand-toggle');
            if (toggle) {
                toggle.textContent = '[collapse]';
            }
        }
        
        // Collapse event
        function collapseEvent(eventLine) {
            eventLine.classList.remove('expanded');
            eventLine.classList.add('collapsed');
            const toggle = eventLine.querySelector('.expand-toggle');
            if (toggle) {
                toggle.textContent = '[expand]';
            }
        }
        
        // Update event visibility based on filter settings
        function updateEventVisibility(eventLine = null) {
            const showSystem = document.getElementById('filter-system').checked;
            const showUserMessages = document.getElementById('filter-user-message').checked;
            
            if (eventLine) {
                // Update single event
                const eventType = eventLine.dataset.type;
                const eventSource = eventLine.dataset.source;
                
                let shouldShow = true;
                
                if (eventType === 'SystemPromptEvent' || eventType.includes('System')) {
                    shouldShow = showSystem;
                } else if (eventType === 'MessageEvent' && eventSource === 'user') {
                    shouldShow = showUserMessages;
                }
                
                eventLine.classList.toggle('hidden', !shouldShow);
            } else {
                // Update all events
                document.querySelectorAll('.event-line').forEach(line => {
                    const eventType = line.dataset.type;
                    const eventSource = line.dataset.source;
                    
                    let shouldShow = true;
                    
                    if (eventType === 'SystemPromptEvent' || eventType.includes('System')) {
                        shouldShow = showSystem;
                    } else if (eventType === 'MessageEvent' && eventSource === 'user') {
                        shouldShow = showUserMessages;
                    }
                    
                    line.classList.toggle('hidden', !shouldShow);
                });
            }
        }
        
        // Set command in input field
        function setCommand(command) {
            document.getElementById('command-input').value = command;
            document.getElementById('command-input').focus();
        }
        
        // Clear terminal
        function clearTerminal() {
            const terminalOutput = document.getElementById('terminal-output');
            
            // Keep only the first system message
            const events = terminalOutput.querySelectorAll('.event-line');
            for (let i = 1; i < events.length; i++) {
                events[i].remove();
            }
            
            // Clear events array and counters
            events.length = 1; // Keep the first event
            resetEventCounters();
            
            // Add clear message
            addEvent({
                type: 'SystemEvent',
                text: 'Terminal cleared.',
                timestamp: new Date().toISOString()
            });
        }
        
        // Reset event counters
        function resetEventCounters() {
            eventCounters = {
                total: 0,
                system: 0,
                message: 0,
                action: 0,
                observation: 0,
                error: 0
            };
            
            // Update display
            document.getElementById('event-count').innerHTML = 'EVENTS: <span>0</span>';
            document.getElementById('stat-total').textContent = '0';
            document.getElementById('stat-system').textContent = '0';
            document.getElementById('stat-message').textContent = '0';
            document.getElementById('stat-action').textContent = '0';
            document.getElementById('stat-observation').textContent = '0';
            document.getElementById('stat-error').textContent = '0';
        }
        
        // Update conversation ID display
        function updateConversationIdDisplay() {
            const display = document.getElementById('conversation-id');
            if (currentConversationId) {
                const shortId = currentConversationId.substring(0, 8) + '...';
                display.textContent = shortId;
                display.title = currentConversationId;
            } else {
                display.textContent = 'None';
                display.title = '';
            }
        }
        
        // Start new conversation
        function newConversation() {
            currentConversationId = null;
            localStorage.removeItem('openbrowser_conversation_id');
            updateConversationIdDisplay();
            
            addEvent({
                type: 'SystemEvent',
                text: 'New conversation started. Previous context cleared.',
                timestamp: new Date().toISOString()
            });
        }
    </script>
</body>
</html>

        .debug-toggle:hover {
            background: #4b5563;
        }

        .debug-toggle span {
            font-size: 12px;
            color: #9ca3af;
        }

        .debug-log {
            font-size: 12px;
            line-height: 1.4;
            color: #d1d5db;
        }

        .debug-log-entry {
            padding: 8px;
            border-bottom: 1px solid #374151;
            margin-bottom: 4px;
        }

        .debug-log-entry:last-child {
            border-bottom: none;
        }

        .debug-log-timestamp {
            color: #9ca3af;
            font-size: 11px;
            margin-right: 8px;
        }

        .debug-log-event {
            color: #60a5fa;
        }

        .debug-log-type {
            color: #34d399;
            margin-right: 8px;
        }

        .debug-log-status {
            color: #fbbf24;
        }

        .debug-log-error {
            color: #f87171;
        }

        .debug-log-success {
            color: #34d399;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                border-left: none;
                border-top: 1px solid #e5e7eb;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>
                <span class="logo">ü§ñ</span>
                OpenBrowserAgent
            </h1>
            <p class="subtitle">AI-powered browser automation with visual feedback</p>
            <div class="status" id="status">Initializing...</div>
        </header>

        <div class="main-content">
            <div class="chat-container">
                <div class="messages" id="messages">
                    <div class="message agent-message">
                        <div class="text">Hello! I'm your OpenBrowserAgent assistant. I can help you control a Chrome browser using natural language commands.</div>
                        <div class="text">I'll show you screenshots after each action so you can see exactly what's happening in the browser.</div>
                        <div class="text">Try asking me to:</div>
                        <div class="text">‚Ä¢ "Open Google and search for something"</div>
                        <div class="text">‚Ä¢ "Navigate to a website and click on links"</div>
                        <div class="text">‚Ä¢ "Type text into a form or search box"</div>
                        <div class="text">‚Ä¢ "Scroll through a page"</div>
                    </div>
                </div>

                <div class="input-container">
                    <textarea 
                        id="messageInput" 
                        placeholder="Type your command here... (e.g., 'Open google.com and search for AI news')" 
                        rows="3"
                    ></textarea>
                    <button id="sendButton" onclick="sendMessage()">Send</button>
                </div>
            </div>

            <div class="sidebar">
                <div class="conversation-info">
                    <h2>Session Info</h2>
                    <p><strong>Conversation ID:</strong> <code id="conversationId">Loading...</code></p>
                    <p><strong>Status:</strong> <span id="connectionStatus">Connecting...</span></p>
                    <p><strong>Browser:</strong> <span id="browserStatus">Checking...</span></p>
                </div>

                <div class="tools-info">
                    <h2>Available Tools</h2>
                    <div class="tool-item">
                        <h4>OpenBrowserTool</h4>
                        <p>Control Chrome browser with mouse, keyboard, tabs, and screenshots.</p>
                    </div>
                    <div class="tool-item">
                        <h4>Terminal</h4>
                        <p>Execute shell commands in the workspace.</p>
                    </div>
                    <div class="tool-item">
                        <h4>File Editor</h4>
                        <p>Create, read, and edit files.</p>
                    </div>
                    <div class="tool-item">
                        <h4>Task Tracker</h4>
                        <p>Organize and track tasks.</p>
                    </div>
                </div>

                <div class="debug-info" id="debugPanel">
                    <div class="debug-toggle" onclick="toggleDebugPanel()">
                        <span>üîç Debug Console</span>
                        <span id="debugToggleText">‚ñº</span>
                    </div>
                    <div id="debugContent" style="display: none;">
                        <h2>SSE Event Log</h2>
                        <div id="debugLog" class="debug-log">
                            <div class="debug-log-entry">
                                <span class="debug-log-timestamp">[00:00:00]</span>
                                <span class="debug-log-status">Ready for events...</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let conversationId = null;
        let isProcessing = false;
        let debugEnabled = true;
        let debugLogEntries = [];
        const MAX_DEBUG_ENTRIES = 50;

        // Debug functions
        function toggleDebugPanel() {
            const content = document.getElementById('debugContent');
            const toggleText = document.getElementById('debugToggleText');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggleText.textContent = '‚ñ≤';
            } else {
                content.style.display = 'none';
                toggleText.textContent = '‚ñº';
            }
        }

        function formatTimestamp() {
            const now = new Date();
            return `[${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}.${now.getMilliseconds().toString().padStart(3, '0')}]`;
        }

        function addDebugLog(type, message, data = null) {
            if (!debugEnabled) return;
            
            const timestamp = formatTimestamp();
            const entry = { timestamp, type, message, data };
            debugLogEntries.push(entry);
            
            // Keep only last MAX_DEBUG_ENTRIES
            if (debugLogEntries.length > MAX_DEBUG_ENTRIES) {
                debugLogEntries.shift();
            }
            
            // Update UI
            updateDebugDisplay();
            
            // Also log to console for development
            const consoleMessage = `${timestamp} ${type}: ${message}`;
            if (type === 'ERROR') {
                console.error(consoleMessage, data);
            } else if (type === 'WARN') {
                console.warn(consoleMessage, data);
            } else {
                console.log(consoleMessage, data);
            }
        }

        function updateDebugDisplay() {
            const debugLog = document.getElementById('debugLog');
            if (!debugLog) return;
            
            let html = '';
            debugLogEntries.forEach(entry => {
                let typeClass = 'debug-log-status';
                if (entry.type === 'ERROR') typeClass = 'debug-log-error';
                if (entry.type === 'SUCCESS') typeClass = 'debug-log-success';
                if (entry.type === 'EVENT') typeClass = 'debug-log-event';
                if (entry.type === 'TYPE') typeClass = 'debug-log-type';
                
                html += `<div class="debug-log-entry">
                    <span class="debug-log-timestamp">${entry.timestamp}</span>
                    <span class="${typeClass}">${entry.type}:</span>
                    <span class="debug-log-message">${entry.message}</span>
                </div>`;
            });
            
            debugLog.innerHTML = html;
            debugLog.scrollTop = debugLog.scrollHeight;
        }

        function logSSEEvent(eventType, data) {
            addDebugLog('EVENT', `SSE ${eventType} received`, data);
            
            // Log detailed event info
            if (data && typeof data === 'object') {
                if (data.type) {
                    addDebugLog('TYPE', `Event type: ${data.type}`);
                }
                if (data.text) {
                    const textPreview = data.text.length > 50 ? data.text.substring(0, 50) + '...' : data.text;
                    addDebugLog('INFO', `Text content: ${textPreview}`);
                }
                if (data.image || (data.images && data.images.length > 0)) {
                    const imageCount = data.image ? 1 : (data.images ? data.images.length : 0);
                    addDebugLog('INFO', `Image content: ${imageCount} image(s)`);
                }
            }
        }

        function logProcessingStatus(status, details = '') {
            addDebugLog('STATUS', status, details);
        }

        function logRenderingInfo(action, elementId = '', details = '') {
            addDebugLog('RENDER', `${action} ${elementId ? `(${elementId})` : ''}`, details);
        }

        function logError(error, context = '') {
            const errorMessage = context ? `${context}: ${error.message || error}` : error.message || error;
            addDebugLog('ERROR', errorMessage, error);
        }

        // Initialize debug display
        window.addEventListener('DOMContentLoaded', () => {
            addDebugLog('INFO', 'Debug console initialized');
            addDebugLog('INFO', 'Ready to receive SSE events');
        });

        // Initialize conversation
        async function initConversation() {
            try {
                logProcessingStatus('Initializing conversation');
                updateStatus('Creating conversation...', 'initializing');
                
                const response = await fetch('/agent/conversations', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error('Failed to create conversation');
                }
                
                const data = await response.json();
                conversationId = data.conversation_id;
                
                document.getElementById('conversationId').textContent = conversationId;
                updateStatus('Ready', 'connected');
                updateConnectionStatus('Connected');
                
                addDebugLog('SUCCESS', `Conversation created: ${conversationId}`);
                logProcessingStatus('Conversation initialized', { conversationId });
            } catch (error) {
                logError(error, 'Error initializing conversation');
                updateStatus('Failed to initialize', 'disconnected');
                updateConnectionStatus('Disconnected');
            }
        }

        // Send message to agent
        async function sendMessage() {
            if (isProcessing) {
                addDebugLog('WARN', 'Attempted to send message while processing');
                return;
            }
            
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (!message) {
                addDebugLog('INFO', 'Attempted to send empty message');
                return;
            }
            
            logProcessingStatus('Sending message to agent', { messageLength: message.length });
            
            // Add user message to chat
            addMessage(message, 'user');
            input.value = '';
            isProcessing = true;
            document.getElementById('sendButton').disabled = true;
            
            // Show typing indicator
            const typingId = showTypingIndicator();
            
            try {
                // Connect to SSE stream
                await connectToSSE(message, typingId);
            } catch (error) {
                logError(error, 'Error sending message');
                addMessage('Error: ' + error.message, 'agent');
                isProcessing = false;
                document.getElementById('sendButton').disabled = false;
                removeTypingIndicator(typingId);
            }
        }

        // Connect to SSE stream for agent response using fetch
        async function connectToSSE(message, typingId) {
            return new Promise(async (resolve, reject) => {
                logProcessingStatus('Starting SSE connection', { message: message.substring(0, 50) + (message.length > 50 ? '...' : ''), typingId });
                logRenderingInfo('Creating', 'typing-indicator', typingId);
                
                let agentMessage = {
                    text: '',
                    images: []
                };
                
                let streamCompleted = false;
                let timeoutId = null;
                let currentEventType = 'agent_event'; // Default event type for backward compatibility
                
                // Set timeout for completion
                timeoutId = setTimeout(() => {
                    if (!streamCompleted) {
                        console.warn('SSE stream timeout after 30 seconds');
                        streamCompleted = true;
                        finishAgentMessage(typingId, agentMessage);
                        resolve();
                    }
                }, 30000); // 30 second timeout
                
                try {
                    // Send message and handle SSE response
                    const response = await fetch(`/agent/conversations/${conversationId}/messages`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ text: message })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Failed to send message: ${response.status} ${response.statusText}`);
                    }
                    
                    // Parse SSE stream from response
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    
                    try {
                        while (true) {
                            const { done, value } = await reader.read();
                            
                            if (done) {
                                // Stream completed
                                if (!streamCompleted) {
                                    streamCompleted = true;
                                    clearTimeout(timeoutId);
                                    finishAgentMessage(typingId, agentMessage);
                                    resolve();
                                }
                                break;
                            }
                            
                            // Decode and process chunks
                            const chunk = decoder.decode(value, { stream: true });
                            buffer += chunk;
                            
                            // Process complete SSE events in buffer
                            const lines = buffer.split('\n');
                            buffer = lines.pop(); // Keep last incomplete line
                            
                            for (let i = 0; i < lines.length; i++) {
                                const line = lines[i].trim();
                                
                                // Skip empty lines and comments
                                if (!line || line.startsWith(':')) {
                                    continue;
                                }
                                
                                // Parse SSE event format: "event: type" or "data: json"
                                if (line.startsWith('event: ')) {
                                    // Event type - we'll handle it with the next data line
                                    currentEventType = line.substring(7).trim(); // Remove "event: "
                                    continue;
                                }
                                else if (line.startsWith('data: ')) {
                                    const jsonData = line.substring(6); // Remove "data: "
                                    try {
                                        const data = JSON.parse(jsonData);
                                        logSSEEvent(currentEventType, data);
                                        
                                        // Unified event handling - support both old and new formats
                                        const eventType = data.type || currentEventType;
                                        
                                        if (currentEventType === 'agent_event' || currentEventType === 'system_event') {
                                            logProcessingStatus('Processing agent/system event', { eventType, currentEventType });
                                            
                                            // Handle agent events with unified format
                                            if (data.text) {
                                                agentMessage.text += data.text + '\n';
                                                addDebugLog('INFO', `Added text to agent message (total: ${agentMessage.text.length} chars)`);
                                            }
                                            // Support both 'image' (singular) and 'images' (plural) fields
                                            if (data.image) {
                                                if (!agentMessage.images) agentMessage.images = [];
                                                agentMessage.images.push(data.image);
                                                addDebugLog('INFO', `Added image to agent message (total: ${agentMessage.images.length} images)`);
                                            }
                                            if (data.images && data.images.length > 0) {
                                                if (!agentMessage.images) agentMessage.images = [];
                                                agentMessage.images.push(...data.images);
                                                addDebugLog('INFO', `Added ${data.images.length} images to agent message (total: ${agentMessage.images.length} images)`);
                                            }
                                            
                                            // Also handle MessageEvent extraction for legacy format
                                            if (eventType === 'MessageEvent' && data.message) {
                                                addDebugLog('TYPE', 'Processing MessageEvent');
                                                const messageContent = extractMessageFromEvent(data.message);
                                                addDebugLog('INFO', `Extracted message: ${messageContent.substring(0, 100)}${messageContent.length > 100 ? '...' : ''}`);
                                                // Check if this is an agent message (not user message)
                                                if (data.message.includes('(agent)') && messageContent) {
                                                    agentMessage.text += messageContent + '\n';
                                                    addDebugLog('INFO', `Added agent message content (total: ${agentMessage.text.length} chars)`);
                                                }
                                            }
                                            
                                            // Update message in real-time if we have content
                                            if (data.text || (eventType === 'MessageEvent' && data.message && data.message.includes('(agent)'))) {
                                                logRenderingInfo('Updating', 'agent-message', { typingId, hasText: !!data.text, hasImages: !!(data.image || (data.images && data.images.length > 0)) });
                                                updateAgentMessage(typingId, agentMessage);
                                            } else {
                                                addDebugLog('INFO', 'No content to update in agent message');
                                            }
                                        }
                                        else if (currentEventType === 'error') {
                                            logError(new Error(data.message || data.error || 'Unknown error'), 'SSE error event');
                                            throw new Error(data.message || data.error || 'Unknown error');
                                        }
                                        else if (currentEventType === 'complete') {
                                            // Stream completed successfully
                                            if (!streamCompleted) {
                                                logProcessingStatus('SSE stream completed', { agentMessageLength: agentMessage.text.length, imageCount: agentMessage.images ? agentMessage.images.length : 0 });
                                                streamCompleted = true;
                                                clearTimeout(timeoutId);
                                                finishAgentMessage(typingId, agentMessage);
                                                resolve();
                                            }
                                            break;
                                        }
                                        else if (currentEventType === 'connected') {
                                            // Connection established
                                            addDebugLog('SUCCESS', 'SSE connection established');
                                        }
                                        // Log other event types for debugging
                                        else {
                                            addDebugLog('WARN', `Unhandled SSE event type: ${currentEventType}`, data);
                                        }
                                    } catch (error) {
                                        logError(error, `Error parsing SSE data: ${jsonData.substring(0, 100)}`);
                                    }
                                }
                            }
                        }
                    } catch (streamError) {
                        if (!streamCompleted) {
                            streamCompleted = true;
                            clearTimeout(timeoutId);
                            reject(streamError);
                        }
                    }
                    
                } catch (error) {
                    if (!streamCompleted) {
                        streamCompleted = true;
                        clearTimeout(timeoutId);
                        reject(error);
                    }
                }
            });
        }

        // Add message to chat
        function addMessage(content, type) {
            logRenderingInfo('Adding', `${type}-message`, typeof content === 'string' ? 
                { length: content.length } : 
                { textLength: content.text ? content.text.length : 0, imageCount: content.images ? content.images.length : 0 });
            
            const messages = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}-message`;
            
            if (type === 'user') {
                messageDiv.textContent = content;
                addDebugLog('RENDER', `User message rendered: ${content.substring(0, 50)}${content.length > 50 ? '...' : ''}`);
            } else if (type === 'agent') {
                if (typeof content === 'string') {
                    messageDiv.innerHTML = `<div class="text">${formatText(content)}</div>`;
                    addDebugLog('RENDER', `Agent message (text only) rendered: ${content.length} chars`);
                } else {
                    let html = '';
                    if (content.text) {
                        html += `<div class="text">${formatText(content.text)}</div>`;
                        addDebugLog('RENDER', `Agent text rendered: ${content.text.length} chars`);
                    }
                    if (content.images && content.images.length > 0) {
                        html += '<div class="images">';
                        content.images.forEach((imgSrc, index) => {
                            html += `<img src="${imgSrc}" alt="Screenshot">`;
                            addDebugLog('RENDER', `Image ${index + 1} added: ${imgSrc.substring(0, 30)}...`);
                        });
                        html += '</div>';
                        addDebugLog('RENDER', `${content.images.length} image(s) rendered`);
                    }
                    messageDiv.innerHTML = html;
                }
            }
            
            messages.appendChild(messageDiv);
            messages.scrollTop = messages.scrollHeight;
            
            addDebugLog('RENDER', `Message appended to DOM, scroll updated`);
            
            return messageDiv;
        }

        // Show typing indicator
        function showTypingIndicator() {
            logRenderingInfo('Showing', 'typing-indicator');
            const messages = document.getElementById('messages');
            const indicator = document.createElement('div');
            indicator.className = 'typing-indicator';
            indicator.id = 'typing-indicator';
            indicator.innerHTML = `
                <span></span>
                <span></span>
                <span></span>
            `;
            messages.appendChild(indicator);
            messages.scrollTop = messages.scrollHeight;
            addDebugLog('RENDER', 'Typing indicator created and displayed');
            return 'typing-indicator';
        }

        // Update agent message in real-time
        function updateAgentMessage(typingId, agentMessage) {
            logRenderingInfo('Updating real-time', `message-${typingId}`, { 
                textLength: agentMessage.text ? agentMessage.text.length : 0, 
                imageCount: agentMessage.images ? agentMessage.images.length : 0 
            });
            
            let indicator = document.getElementById(typingId);
            if (!indicator) {
                addDebugLog('RENDER', `Creating new agent message with ID: ${typingId}`);
                indicator = addMessage(agentMessage, 'agent');
                indicator.id = typingId;
            } else {
                addDebugLog('RENDER', `Updating existing agent message with ID: ${typingId}`);
                let html = '';
                if (agentMessage.text) {
                    html += `<div class="text">${formatText(agentMessage.text)}</div>`;
                    addDebugLog('RENDER', `Updated text: ${agentMessage.text.length} chars`);
                }
                if (agentMessage.images && agentMessage.images.length > 0) {
                    html += '<div class="images">';
                    agentMessage.images.forEach((imgSrc, index) => {
                        html += `<img src="${imgSrc}" alt="Screenshot">`;
                        addDebugLog('RENDER', `Updated image ${index + 1}`);
                    });
                    html += '</div>';
                    addDebugLog('RENDER', `Updated ${agentMessage.images.length} image(s)`);
                }
                indicator.innerHTML = html;
            }
            
            const messages = document.getElementById('messages');
            messages.scrollTop = messages.scrollHeight;
            addDebugLog('RENDER', `Message updated, scroll position adjusted`);
        }

        // Finish agent message and remove typing indicator
        function finishAgentMessage(typingId, agentMessage) {
            logProcessingStatus('Finishing agent message', { typingId, textLength: agentMessage.text ? agentMessage.text.length : 0, imageCount: agentMessage.images ? agentMessage.images.length : 0 });
            removeTypingIndicator(typingId);
            addMessage(agentMessage, 'agent');
            isProcessing = false;
            document.getElementById('sendButton').disabled = false;
            addDebugLog('SUCCESS', 'Agent message completed and ready for new input');
        }

        // Remove typing indicator
        function removeTypingIndicator(typingId) {
            const indicator = document.getElementById(typingId);
            if (indicator) {
                indicator.remove();
                addDebugLog('RENDER', `Removed typing indicator: ${typingId}`);
            } else {
                addDebugLog('INFO', `Typing indicator not found: ${typingId}`);
            }
        }

        // Format text with line breaks
        function formatText(text) {
            return text.replace(/\n/g, '<br>');
        }

        // Extract message content from MessageEvent string
        function extractMessageFromEvent(eventString) {
            try {
                // Format: "MessageEvent (agent)\n  assistant: message text"
                // or "MessageEvent (user)\n  user: message text"
                const lines = eventString.split('\n');
                if (lines.length >= 2) {
                    // Find the line with the message content
                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (line.startsWith('assistant: ')) {
                            return line.substring('assistant: '.length);
                        }
                        if (line.startsWith('user: ')) {
                            return line.substring('user: '.length);
                        }
                    }
                    // If no prefix found, return everything after first line
                    return lines.slice(1).join('\n').trim();
                }
                // If single line, try to extract content after parentheses
                const match = eventString.match(/MessageEvent\s*\([^)]+\)\s*(.+)/);
                if (match && match[1]) {
                    return match[1].trim();
                }
            } catch (error) {
                console.error('Error extracting message from event:', error);
            }
            // Fallback: return the original string
            return eventString;
        }

        // Update status display
        function updateStatus(text, className) {
            const status = document.getElementById('status');
            status.textContent = text;
            status.className = `status ${className}`;
        }

        // Update connection status
        function updateConnectionStatus(text) {
            document.getElementById('connectionStatus').textContent = text;
        }

        // Update browser status
        function updateBrowserStatus(text) {
            document.getElementById('browserStatus').textContent = text;
        }

        // Handle Enter key in textarea
        document.getElementById('messageInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // Check browser server status
        async function checkBrowserStatus() {
            try {
                const response = await fetch('/health');
                const data = await response.json();
                
                if (data.websocket_connected) {
                    updateBrowserStatus('Connected ‚úÖ');
                } else {
                    updateBrowserStatus('Extension not connected ‚ö†Ô∏è');
                }
            } catch (error) {
                updateBrowserStatus('Server not reachable ‚ùå');
            }
        }

        // Initialize on page load
        window.onload = async () => {
            await initConversation();
            await checkBrowserStatus();
            
            // Check browser status periodically
            setInterval(checkBrowserStatus, 10000);
        };
    </script>
</body>
</html>