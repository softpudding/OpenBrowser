<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenBrowserAgent - AI Browser Assistant</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            line-height: 1.6;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
            overflow: hidden;
            min-height: 90vh;
        }

        header {
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 24px 32px;
        }

        h1 {
            font-size: 28px;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        h1 .logo {
            font-size: 32px;
        }

        .subtitle {
            font-size: 16px;
            opacity: 0.9;
            margin-bottom: 4px;
        }

        .status {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 14px;
            margin-top: 8px;
        }

        .status.connected {
            background: #10b981;
        }

        .status.disconnected {
            background: #ef4444;
        }

        .main-content {
            display: flex;
            height: calc(90vh - 120px);
        }

        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 24px;
        }

        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            background: #f9fafb;
            border-radius: 12px;
            margin-bottom: 16px;
        }

        .message {
            margin-bottom: 16px;
            padding: 12px 16px;
            border-radius: 12px;
            max-width: 80%;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .user-message {
            background: #3b82f6;
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 4px;
        }

        .agent-message {
            background: white;
            border: 1px solid #e5e7eb;
            margin-right: auto;
            border-bottom-left-radius: 4px;
        }

        .agent-message .text {
            white-space: pre-wrap;
            margin-bottom: 12px;
        }

        .agent-message .images {
            margin-top: 12px;
        }

        .agent-message img {
            max-width: 100%;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            margin-bottom: 8px;
        }

        .input-container {
            display: flex;
            gap: 12px;
            padding: 16px;
            background: white;
            border-top: 1px solid #e5e7eb;
        }

        textarea {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            font-size: 16px;
            resize: none;
            font-family: inherit;
            transition: border-color 0.2s;
        }

        textarea:focus {
            outline: none;
            border-color: #3b82f6;
        }

        button {
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 0 24px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .sidebar {
            width: 300px;
            background: #f9fafb;
            border-left: 1px solid #e5e7eb;
            padding: 24px;
            overflow-y: auto;
        }

        .sidebar h2 {
            font-size: 18px;
            margin-bottom: 16px;
            color: #374151;
        }

        .conversation-info {
            background: white;
            padding: 16px;
            border-radius: 12px;
            margin-bottom: 24px;
            border: 1px solid #e5e7eb;
        }

        .conversation-info p {
            margin-bottom: 8px;
            font-size: 14px;
        }

        .conversation-info code {
            background: #f3f4f6;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 13px;
        }

        .tools-info {
            background: white;
            padding: 16px;
            border-radius: 12px;
            border: 1px solid #e5e7eb;
        }

        .tool-item {
            margin-bottom: 12px;
            padding: 12px;
            background: #f8fafc;
            border-radius: 8px;
            border-left: 4px solid #3b82f6;
        }

        .tool-item h4 {
            font-size: 14px;
            margin-bottom: 4px;
            color: #1e40af;
        }

        .tool-item p {
            font-size: 13px;
            color: #6b7280;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #e5e7eb;
            border-top-color: #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .typing-indicator {
            display: flex;
            gap: 4px;
            padding: 12px 16px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            width: fit-content;
            margin-bottom: 16px;
        }

        .typing-indicator span {
            width: 8px;
            height: 8px;
            background: #9ca3af;
            border-radius: 50%;
            animation: bounce 1.4s infinite;
        }

        .typing-indicator span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-indicator span:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes bounce {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-8px); }
        }

        /* Debug panel styles */
        .debug-info {
            background: #1f2937;
            padding: 16px;
            border-radius: 12px;
            margin-top: 24px;
            border: 1px solid #374151;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        }

        .debug-info h2 {
            font-size: 18px;
            margin-bottom: 12px;
            color: #d1d5db;
        }

        .debug-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            padding: 8px 12px;
            background: #374151;
            border-radius: 8px;
            margin-bottom: 12px;
            color: #d1d5db;
            font-size: 14px;
        }

        .debug-toggle:hover {
            background: #4b5563;
        }

        .debug-toggle span {
            font-size: 12px;
            color: #9ca3af;
        }

        .debug-log {
            font-size: 12px;
            line-height: 1.4;
            color: #d1d5db;
        }

        .debug-log-entry {
            padding: 8px;
            border-bottom: 1px solid #374151;
            margin-bottom: 4px;
        }

        .debug-log-entry:last-child {
            border-bottom: none;
        }

        .debug-log-timestamp {
            color: #9ca3af;
            font-size: 11px;
            margin-right: 8px;
        }

        .debug-log-event {
            color: #60a5fa;
        }

        .debug-log-type {
            color: #34d399;
            margin-right: 8px;
        }

        .debug-log-status {
            color: #fbbf24;
        }

        .debug-log-error {
            color: #f87171;
        }

        .debug-log-success {
            color: #34d399;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                border-left: none;
                border-top: 1px solid #e5e7eb;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>
                <span class="logo">ü§ñ</span>
                OpenBrowserAgent
            </h1>
            <p class="subtitle">AI-powered browser automation with visual feedback</p>
            <div class="status" id="status">Initializing...</div>
        </header>

        <div class="main-content">
            <div class="chat-container">
                <div class="messages" id="messages">
                    <div class="message agent-message">
                        <div class="text">Hello! I'm your OpenBrowserAgent assistant. I can help you control a Chrome browser using natural language commands.</div>
                        <div class="text">I'll show you screenshots after each action so you can see exactly what's happening in the browser.</div>
                        <div class="text">Try asking me to:</div>
                        <div class="text">‚Ä¢ "Open Google and search for something"</div>
                        <div class="text">‚Ä¢ "Navigate to a website and click on links"</div>
                        <div class="text">‚Ä¢ "Type text into a form or search box"</div>
                        <div class="text">‚Ä¢ "Scroll through a page"</div>
                    </div>
                </div>

                <div class="input-container">
                    <textarea 
                        id="messageInput" 
                        placeholder="Type your command here... (e.g., 'Open google.com and search for AI news')" 
                        rows="3"
                    ></textarea>
                    <button id="sendButton" onclick="sendMessage()">Send</button>
                </div>
            </div>

            <div class="sidebar">
                <div class="conversation-info">
                    <h2>Session Info</h2>
                    <p><strong>Conversation ID:</strong> <code id="conversationId">Loading...</code></p>
                    <p><strong>Status:</strong> <span id="connectionStatus">Connecting...</span></p>
                    <p><strong>Browser:</strong> <span id="browserStatus">Checking...</span></p>
                </div>

                <div class="tools-info">
                    <h2>Available Tools</h2>
                    <div class="tool-item">
                        <h4>OpenBrowserTool</h4>
                        <p>Control Chrome browser with mouse, keyboard, tabs, and screenshots.</p>
                    </div>
                    <div class="tool-item">
                        <h4>Terminal</h4>
                        <p>Execute shell commands in the workspace.</p>
                    </div>
                    <div class="tool-item">
                        <h4>File Editor</h4>
                        <p>Create, read, and edit files.</p>
                    </div>
                    <div class="tool-item">
                        <h4>Task Tracker</h4>
                        <p>Organize and track tasks.</p>
                    </div>
                </div>

                <div class="debug-info" id="debugPanel">
                    <div class="debug-toggle" onclick="toggleDebugPanel()">
                        <span>üîç Debug Console</span>
                        <span id="debugToggleText">‚ñº</span>
                    </div>
                    <div id="debugContent" style="display: none;">
                        <h2>SSE Event Log</h2>
                        <div id="debugLog" class="debug-log">
                            <div class="debug-log-entry">
                                <span class="debug-log-timestamp">[00:00:00]</span>
                                <span class="debug-log-status">Ready for events...</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let conversationId = null;
        let isProcessing = false;
        let debugEnabled = true;
        let debugLogEntries = [];
        const MAX_DEBUG_ENTRIES = 50;

        // Debug functions
        function toggleDebugPanel() {
            const content = document.getElementById('debugContent');
            const toggleText = document.getElementById('debugToggleText');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggleText.textContent = '‚ñ≤';
            } else {
                content.style.display = 'none';
                toggleText.textContent = '‚ñº';
            }
        }

        function formatTimestamp() {
            const now = new Date();
            return `[${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}.${now.getMilliseconds().toString().padStart(3, '0')}]`;
        }

        function addDebugLog(type, message, data = null) {
            if (!debugEnabled) return;
            
            const timestamp = formatTimestamp();
            const entry = { timestamp, type, message, data };
            debugLogEntries.push(entry);
            
            // Keep only last MAX_DEBUG_ENTRIES
            if (debugLogEntries.length > MAX_DEBUG_ENTRIES) {
                debugLogEntries.shift();
            }
            
            // Update UI
            updateDebugDisplay();
            
            // Also log to console for development
            const consoleMessage = `${timestamp} ${type}: ${message}`;
            if (type === 'ERROR') {
                console.error(consoleMessage, data);
            } else if (type === 'WARN') {
                console.warn(consoleMessage, data);
            } else {
                console.log(consoleMessage, data);
            }
        }

        function updateDebugDisplay() {
            const debugLog = document.getElementById('debugLog');
            if (!debugLog) return;
            
            let html = '';
            debugLogEntries.forEach(entry => {
                let typeClass = 'debug-log-status';
                if (entry.type === 'ERROR') typeClass = 'debug-log-error';
                if (entry.type === 'SUCCESS') typeClass = 'debug-log-success';
                if (entry.type === 'EVENT') typeClass = 'debug-log-event';
                if (entry.type === 'TYPE') typeClass = 'debug-log-type';
                
                html += `<div class="debug-log-entry">
                    <span class="debug-log-timestamp">${entry.timestamp}</span>
                    <span class="${typeClass}">${entry.type}:</span>
                    <span class="debug-log-message">${entry.message}</span>
                </div>`;
            });
            
            debugLog.innerHTML = html;
            debugLog.scrollTop = debugLog.scrollHeight;
        }

        function logSSEEvent(eventType, data) {
            addDebugLog('EVENT', `SSE ${eventType} received`, data);
            
            // Log detailed event info
            if (data && typeof data === 'object') {
                if (data.type) {
                    addDebugLog('TYPE', `Event type: ${data.type}`);
                }
                if (data.text) {
                    const textPreview = data.text.length > 50 ? data.text.substring(0, 50) + '...' : data.text;
                    addDebugLog('INFO', `Text content: ${textPreview}`);
                }
                if (data.image || (data.images && data.images.length > 0)) {
                    const imageCount = data.image ? 1 : (data.images ? data.images.length : 0);
                    addDebugLog('INFO', `Image content: ${imageCount} image(s)`);
                }
            }
        }

        function logProcessingStatus(status, details = '') {
            addDebugLog('STATUS', status, details);
        }

        function logRenderingInfo(action, elementId = '', details = '') {
            addDebugLog('RENDER', `${action} ${elementId ? `(${elementId})` : ''}`, details);
        }

        function logError(error, context = '') {
            const errorMessage = context ? `${context}: ${error.message || error}` : error.message || error;
            addDebugLog('ERROR', errorMessage, error);
        }

        // Initialize debug display
        window.addEventListener('DOMContentLoaded', () => {
            addDebugLog('INFO', 'Debug console initialized');
            addDebugLog('INFO', 'Ready to receive SSE events');
        });

        // Initialize conversation
        async function initConversation() {
            try {
                logProcessingStatus('Initializing conversation');
                updateStatus('Creating conversation...', 'initializing');
                
                const response = await fetch('/agent/conversations', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error('Failed to create conversation');
                }
                
                const data = await response.json();
                conversationId = data.conversation_id;
                
                document.getElementById('conversationId').textContent = conversationId;
                updateStatus('Ready', 'connected');
                updateConnectionStatus('Connected');
                
                addDebugLog('SUCCESS', `Conversation created: ${conversationId}`);
                logProcessingStatus('Conversation initialized', { conversationId });
            } catch (error) {
                logError(error, 'Error initializing conversation');
                updateStatus('Failed to initialize', 'disconnected');
                updateConnectionStatus('Disconnected');
            }
        }

        // Send message to agent
        async function sendMessage() {
            if (isProcessing) {
                addDebugLog('WARN', 'Attempted to send message while processing');
                return;
            }
            
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (!message) {
                addDebugLog('INFO', 'Attempted to send empty message');
                return;
            }
            
            logProcessingStatus('Sending message to agent', { messageLength: message.length });
            
            // Add user message to chat
            addMessage(message, 'user');
            input.value = '';
            isProcessing = true;
            document.getElementById('sendButton').disabled = true;
            
            // Show typing indicator
            const typingId = showTypingIndicator();
            
            try {
                // Connect to SSE stream
                await connectToSSE(message, typingId);
            } catch (error) {
                logError(error, 'Error sending message');
                addMessage('Error: ' + error.message, 'agent');
                isProcessing = false;
                document.getElementById('sendButton').disabled = false;
                removeTypingIndicator(typingId);
            }
        }

        // Connect to SSE stream for agent response using fetch
        async function connectToSSE(message, typingId) {
            return new Promise(async (resolve, reject) => {
                logProcessingStatus('Starting SSE connection', { message: message.substring(0, 50) + (message.length > 50 ? '...' : ''), typingId });
                logRenderingInfo('Creating', 'typing-indicator', typingId);
                
                let agentMessage = {
                    text: '',
                    images: []
                };
                
                let streamCompleted = false;
                let timeoutId = null;
                let currentEventType = 'agent_event'; // Default event type for backward compatibility
                
                // Set timeout for completion
                timeoutId = setTimeout(() => {
                    if (!streamCompleted) {
                        console.warn('SSE stream timeout after 30 seconds');
                        streamCompleted = true;
                        finishAgentMessage(typingId, agentMessage);
                        resolve();
                    }
                }, 30000); // 30 second timeout
                
                try {
                    // Send message and handle SSE response
                    const response = await fetch(`/agent/conversations/${conversationId}/messages`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ text: message })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Failed to send message: ${response.status} ${response.statusText}`);
                    }
                    
                    // Parse SSE stream from response
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    
                    try {
                        while (true) {
                            const { done, value } = await reader.read();
                            
                            if (done) {
                                // Stream completed
                                if (!streamCompleted) {
                                    streamCompleted = true;
                                    clearTimeout(timeoutId);
                                    finishAgentMessage(typingId, agentMessage);
                                    resolve();
                                }
                                break;
                            }
                            
                            // Decode and process chunks
                            const chunk = decoder.decode(value, { stream: true });
                            buffer += chunk;
                            
                            // Process complete SSE events in buffer
                            const lines = buffer.split('\n');
                            buffer = lines.pop(); // Keep last incomplete line
                            
                            for (let i = 0; i < lines.length; i++) {
                                const line = lines[i].trim();
                                
                                // Skip empty lines and comments
                                if (!line || line.startsWith(':')) {
                                    continue;
                                }
                                
                                // Parse SSE event format: "event: type" or "data: json"
                                if (line.startsWith('event: ')) {
                                    // Event type - we'll handle it with the next data line
                                    currentEventType = line.substring(7).trim(); // Remove "event: "
                                    continue;
                                }
                                else if (line.startsWith('data: ')) {
                                    const jsonData = line.substring(6); // Remove "data: "
                                    try {
                                        const data = JSON.parse(jsonData);
                                        logSSEEvent(currentEventType, data);
                                        
                                        // Unified event handling - support both old and new formats
                                        const eventType = data.type || currentEventType;
                                        
                                        if (currentEventType === 'agent_event' || currentEventType === 'system_event') {
                                            logProcessingStatus('Processing agent/system event', { eventType, currentEventType });
                                            
                                            // Handle agent events with unified format
                                            if (data.text) {
                                                agentMessage.text += data.text + '\n';
                                                addDebugLog('INFO', `Added text to agent message (total: ${agentMessage.text.length} chars)`);
                                            }
                                            // Support both 'image' (singular) and 'images' (plural) fields
                                            if (data.image) {
                                                if (!agentMessage.images) agentMessage.images = [];
                                                agentMessage.images.push(data.image);
                                                addDebugLog('INFO', `Added image to agent message (total: ${agentMessage.images.length} images)`);
                                            }
                                            if (data.images && data.images.length > 0) {
                                                if (!agentMessage.images) agentMessage.images = [];
                                                agentMessage.images.push(...data.images);
                                                addDebugLog('INFO', `Added ${data.images.length} images to agent message (total: ${agentMessage.images.length} images)`);
                                            }
                                            
                                            // Also handle MessageEvent extraction for legacy format
                                            if (eventType === 'MessageEvent' && data.message) {
                                                addDebugLog('TYPE', 'Processing MessageEvent');
                                                const messageContent = extractMessageFromEvent(data.message);
                                                addDebugLog('INFO', `Extracted message: ${messageContent.substring(0, 100)}${messageContent.length > 100 ? '...' : ''}`);
                                                // Check if this is an agent message (not user message)
                                                if (data.message.includes('(agent)') && messageContent) {
                                                    agentMessage.text += messageContent + '\n';
                                                    addDebugLog('INFO', `Added agent message content (total: ${agentMessage.text.length} chars)`);
                                                }
                                            }
                                            
                                            // Update message in real-time if we have content
                                            if (data.text || (eventType === 'MessageEvent' && data.message && data.message.includes('(agent)'))) {
                                                logRenderingInfo('Updating', 'agent-message', { typingId, hasText: !!data.text, hasImages: !!(data.image || (data.images && data.images.length > 0)) });
                                                updateAgentMessage(typingId, agentMessage);
                                            } else {
                                                addDebugLog('INFO', 'No content to update in agent message');
                                            }
                                        }
                                        else if (currentEventType === 'error') {
                                            logError(new Error(data.message || data.error || 'Unknown error'), 'SSE error event');
                                            throw new Error(data.message || data.error || 'Unknown error');
                                        }
                                        else if (currentEventType === 'complete') {
                                            // Stream completed successfully
                                            if (!streamCompleted) {
                                                logProcessingStatus('SSE stream completed', { agentMessageLength: agentMessage.text.length, imageCount: agentMessage.images ? agentMessage.images.length : 0 });
                                                streamCompleted = true;
                                                clearTimeout(timeoutId);
                                                finishAgentMessage(typingId, agentMessage);
                                                resolve();
                                            }
                                            break;
                                        }
                                        else if (currentEventType === 'connected') {
                                            // Connection established
                                            addDebugLog('SUCCESS', 'SSE connection established');
                                        }
                                        // Log other event types for debugging
                                        else {
                                            addDebugLog('WARN', `Unhandled SSE event type: ${currentEventType}`, data);
                                        }
                                    } catch (error) {
                                        logError(error, `Error parsing SSE data: ${jsonData.substring(0, 100)}`);
                                    }
                                }
                            }
                        }
                    } catch (streamError) {
                        if (!streamCompleted) {
                            streamCompleted = true;
                            clearTimeout(timeoutId);
                            reject(streamError);
                        }
                    }
                    
                } catch (error) {
                    if (!streamCompleted) {
                        streamCompleted = true;
                        clearTimeout(timeoutId);
                        reject(error);
                    }
                }
            });
        }

        // Add message to chat
        function addMessage(content, type) {
            logRenderingInfo('Adding', `${type}-message`, typeof content === 'string' ? 
                { length: content.length } : 
                { textLength: content.text ? content.text.length : 0, imageCount: content.images ? content.images.length : 0 });
            
            const messages = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}-message`;
            
            if (type === 'user') {
                messageDiv.textContent = content;
                addDebugLog('RENDER', `User message rendered: ${content.substring(0, 50)}${content.length > 50 ? '...' : ''}`);
            } else if (type === 'agent') {
                if (typeof content === 'string') {
                    messageDiv.innerHTML = `<div class="text">${formatText(content)}</div>`;
                    addDebugLog('RENDER', `Agent message (text only) rendered: ${content.length} chars`);
                } else {
                    let html = '';
                    if (content.text) {
                        html += `<div class="text">${formatText(content.text)}</div>`;
                        addDebugLog('RENDER', `Agent text rendered: ${content.text.length} chars`);
                    }
                    if (content.images && content.images.length > 0) {
                        html += '<div class="images">';
                        content.images.forEach((imgSrc, index) => {
                            html += `<img src="${imgSrc}" alt="Screenshot">`;
                            addDebugLog('RENDER', `Image ${index + 1} added: ${imgSrc.substring(0, 30)}...`);
                        });
                        html += '</div>';
                        addDebugLog('RENDER', `${content.images.length} image(s) rendered`);
                    }
                    messageDiv.innerHTML = html;
                }
            }
            
            messages.appendChild(messageDiv);
            messages.scrollTop = messages.scrollHeight;
            
            addDebugLog('RENDER', `Message appended to DOM, scroll updated`);
            
            return messageDiv;
        }

        // Show typing indicator
        function showTypingIndicator() {
            logRenderingInfo('Showing', 'typing-indicator');
            const messages = document.getElementById('messages');
            const indicator = document.createElement('div');
            indicator.className = 'typing-indicator';
            indicator.id = 'typing-indicator';
            indicator.innerHTML = `
                <span></span>
                <span></span>
                <span></span>
            `;
            messages.appendChild(indicator);
            messages.scrollTop = messages.scrollHeight;
            addDebugLog('RENDER', 'Typing indicator created and displayed');
            return 'typing-indicator';
        }

        // Update agent message in real-time
        function updateAgentMessage(typingId, agentMessage) {
            logRenderingInfo('Updating real-time', `message-${typingId}`, { 
                textLength: agentMessage.text ? agentMessage.text.length : 0, 
                imageCount: agentMessage.images ? agentMessage.images.length : 0 
            });
            
            let indicator = document.getElementById(typingId);
            if (!indicator) {
                addDebugLog('RENDER', `Creating new agent message with ID: ${typingId}`);
                indicator = addMessage(agentMessage, 'agent');
                indicator.id = typingId;
            } else {
                addDebugLog('RENDER', `Updating existing agent message with ID: ${typingId}`);
                let html = '';
                if (agentMessage.text) {
                    html += `<div class="text">${formatText(agentMessage.text)}</div>`;
                    addDebugLog('RENDER', `Updated text: ${agentMessage.text.length} chars`);
                }
                if (agentMessage.images && agentMessage.images.length > 0) {
                    html += '<div class="images">';
                    agentMessage.images.forEach((imgSrc, index) => {
                        html += `<img src="${imgSrc}" alt="Screenshot">`;
                        addDebugLog('RENDER', `Updated image ${index + 1}`);
                    });
                    html += '</div>';
                    addDebugLog('RENDER', `Updated ${agentMessage.images.length} image(s)`);
                }
                indicator.innerHTML = html;
            }
            
            const messages = document.getElementById('messages');
            messages.scrollTop = messages.scrollHeight;
            addDebugLog('RENDER', `Message updated, scroll position adjusted`);
        }

        // Finish agent message and remove typing indicator
        function finishAgentMessage(typingId, agentMessage) {
            logProcessingStatus('Finishing agent message', { typingId, textLength: agentMessage.text ? agentMessage.text.length : 0, imageCount: agentMessage.images ? agentMessage.images.length : 0 });
            removeTypingIndicator(typingId);
            addMessage(agentMessage, 'agent');
            isProcessing = false;
            document.getElementById('sendButton').disabled = false;
            addDebugLog('SUCCESS', 'Agent message completed and ready for new input');
        }

        // Remove typing indicator
        function removeTypingIndicator(typingId) {
            const indicator = document.getElementById(typingId);
            if (indicator) {
                indicator.remove();
                addDebugLog('RENDER', `Removed typing indicator: ${typingId}`);
            } else {
                addDebugLog('INFO', `Typing indicator not found: ${typingId}`);
            }
        }

        // Format text with line breaks
        function formatText(text) {
            return text.replace(/\n/g, '<br>');
        }

        // Extract message content from MessageEvent string
        function extractMessageFromEvent(eventString) {
            try {
                // Format: "MessageEvent (agent)\n  assistant: message text"
                // or "MessageEvent (user)\n  user: message text"
                const lines = eventString.split('\n');
                if (lines.length >= 2) {
                    // Find the line with the message content
                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (line.startsWith('assistant: ')) {
                            return line.substring('assistant: '.length);
                        }
                        if (line.startsWith('user: ')) {
                            return line.substring('user: '.length);
                        }
                    }
                    // If no prefix found, return everything after first line
                    return lines.slice(1).join('\n').trim();
                }
                // If single line, try to extract content after parentheses
                const match = eventString.match(/MessageEvent\s*\([^)]+\)\s*(.+)/);
                if (match && match[1]) {
                    return match[1].trim();
                }
            } catch (error) {
                console.error('Error extracting message from event:', error);
            }
            // Fallback: return the original string
            return eventString;
        }

        // Update status display
        function updateStatus(text, className) {
            const status = document.getElementById('status');
            status.textContent = text;
            status.className = `status ${className}`;
        }

        // Update connection status
        function updateConnectionStatus(text) {
            document.getElementById('connectionStatus').textContent = text;
        }

        // Update browser status
        function updateBrowserStatus(text) {
            document.getElementById('browserStatus').textContent = text;
        }

        // Handle Enter key in textarea
        document.getElementById('messageInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // Check browser server status
        async function checkBrowserStatus() {
            try {
                const response = await fetch('/health');
                const data = await response.json();
                
                if (data.websocket_connected) {
                    updateBrowserStatus('Connected ‚úÖ');
                } else {
                    updateBrowserStatus('Extension not connected ‚ö†Ô∏è');
                }
            } catch (error) {
                updateBrowserStatus('Server not reachable ‚ùå');
            }
        }

        // Initialize on page load
        window.onload = async () => {
            await initConversation();
            await checkBrowserStatus();
            
            // Check browser status periodically
            setInterval(checkBrowserStatus, 10000);
        };
    </script>
</body>
</html>