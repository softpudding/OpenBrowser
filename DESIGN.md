我们现在的核心目标是实现一个本地Chrome的命令行控制系统。我们希望完成一个Local Chrome Server，他通过控制Chrome上的插件，做到：
1. 实时获取当前chrome界面截图。
2. 获取web页面鼠标的完全控制权：可以移动、点击鼠标。
3. 可以键入内容。

这个Server可能可以以命令行的形式拉起，获取用户命令；也可以以REST API获取命令。大致上，分为几种命令：
1. TABS 控制相关
    - 打开新tab （url：xxx）
    - 列出所有当前的tab
    - 关掉某一个tab
2. 鼠标操作相关
    - MOVE 鼠标 必须采用相对坐标 比如 MOVE [-100, -100] 而不是移动到一个绝对位置。（这里需要一个假设，我们可以假设用户的浏览器界面分辨率是2K或者其他合理分辨率，我们将这个记为预设分辨率；将实际的分辨率记为实际分辨率。在调用的时候，调用者给出的总是预设分辨率；但我们可能需要转化成实际分辨率操作浏览器，请注意）。
    - 鼠标点击（分左键/右键等）
    - 鼠标Scroll操作（上/下）
3. 键盘相关（往往需要鼠标配合，比如鼠标先点击输入框才能输入）
    - enter键
    - 输入文字等
4. 获取实时页面截图。截图里必须包含清晰的鼠标。

这个Server主要通过chrome浏览器插件和本地浏览器交互。本地浏览器插件我不太会写，我给你提供了一个很好的example：reference/AIPex。这个项目有一些已经比较好的实践，可以进行参考，他实现了鼠标的控制、文字输入等等内容。但要注意我们的逻辑和他是不一样的。我们要提供的是完全视觉化的操作接口，不用html selector等辅助；我们所有操作基于基于像素的鼠标操作、键盘输入来实现。

在实现的时候，server层用python实现，用uv维护python的环境；插件用typescript实现，参考reference/AIPex。

在完成以上设计后，我希望你同时设计一套完整的回归测试。这套测试的逻辑应该是给出一个含有既定任务的html（例如一些需要点击的按钮、一些需要输入文字的地方、一些需要点击的跳转、一些需要滚动的页面），然后测试我们的server能否通过server层的命令完成html的任务。

同时你要给我提供一个可以操作server实时调试的命令行程序，让我可以不停的通过命令行发送命令来操作鼠标、输入文字，操作web页面。

## 实现状态更新 (2025-02-17)

### ✅ 已实现的核心功能

1. **完整的鼠标控制系统**
   - 两层控制架构：底层CDP控制 + 上层可视化指针
   - 可视化鼠标指针（传统箭头样式，智能变色）
   - 鼠标位置跟踪与边界限制（0-3840x0-2160）
   - 一键重置到屏幕中心：`chrome-cli mouse reset`

2. **改进的CLI工具**
   - 交互模式支持箭头键编辑（readline集成）
   - 新增`mouse reset`命令
   - 修复了命令导入错误和装饰器问题

3. **WebSocket连接稳定性**
   - 修复了403 Forbidden错误
   - 扩展自动重连机制
   - Content script自动注入

4. **可视化反馈系统**
   - 指针颜色智能变化：链接/按钮（蓝色）、输入框（绿色）
   - 点击动画（紫色脉冲）
   - 滚动方向指示
   - 拖拽状态显示

### 🔧 技术实现细节

- **扩展架构**：Background script处理命令，Content script显示可视化指针
- **坐标系统**：相对移动 + 边界检查，防止负坐标溢出
- **通信协议**：WebSocket实时双向通信，JSON命令格式
- **错误处理**：自动恢复机制，详细的调试日志

### 🚀 使用示例

```bash
# 启动服务器
uv run local-chrome-server serve --log-level DEBUG

# 交互式控制（支持箭头键编辑）
uv run chrome-cli interactive

# 一键重置鼠标到屏幕中心
uv run chrome-cli mouse reset

# 精确控制特定标签页
uv run chrome-cli tabs list
uv run chrome-cli mouse move --dx 100 --dy 50 --tab-id <ID>
```

### 📋 待解决的问题

1. **截图功能**：WebSocket连接在某些情况下断开导致失败
2. **多标签页同步**：需要更好的标签页状态管理
3. **性能优化**：大规模截图传输的压缩和缓存

### 🎯 设计原则验证

✅ **纯视觉化操作**：所有操作基于像素坐标，无需HTML选择器  
✅ **实时反馈**：可视化指针提供操作可视化反馈  
✅ **易于调试**：详细的日志和交互式命令行工具  
✅ **稳定性**：边界检查、错误恢复、自动重连机制